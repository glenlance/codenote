main函数保存在名为main的包里。如果main函数不在main包里，构建工具就不会生成可执行的文件
go语言的每个代码文件都属于一个包,main.go也不例外。
一个包定义一组编译过的代码，包的名字类似命名空间，可以用来间接访问包内声明的标识符。这个特性可以把不同包中定义的同名标识符区别开。

所有处于同一个文件夹里的代码文件，必须使用同一个包名。按照惯例，包和文件夹同名。就像之前说的，一个包定义一组编译后的代码，每段代码都描述包的一部分。

与第三方包不同，从标准库中导入代码时，只需要给出要导入的包名。编译器查找包的时候，
总是会到 GOROOT 和 GOPATH 环境变量（如代码清单 2-9 所示）引用的位置去查找。

log 包提供打印日志信息到标准输出（stdout）、标准错误（stderr）或者自定义设备的
功能。

sync 包提供同步 goroutine 的功能。

变量没有定义在任何函数作用域内，所以会被当成包级变量。

在 Go 语言里，标识符要么从包里公开，要么不从包里公开。当代码导入了一个包时，程序
可以直接访问这个包中任意一个公开的标识符。这些标识符以大写字母开头。以小写字母开头的
标识符是不公开的，不能被其他包中的代码直接访问。但是，其他包可以间接访问不公开的标识
符。例如，一个函数可以返回一个未公开类型的值，那么这个函数的任何调用者，哪怕调用者不
是在这个包里声明的，都可以访问这个值。

map 是 Go 语言里的一个引用类型，需要使用 make 来构造。如果不先构造 map 并将构造后
的值赋值给变量，会在试图使用这个 map 变量时收到出错信息。这是因为 map 变量默认的零值
是 nil。在第 4 章我们会进一步了解关于映射的细节。

在 Go 语言中，所有变量都被初始化为其零值。对于数值类型，零值是 0；对于字符串类型，
零值是空字符串；对于布尔类型，零值是 false；对于指针，零值是 nil。对于引用类型来说，
所引用的底层数据结构会被初始化为对应的零值。但是被声明为其零值的引用类型的变量，会返
回 nil 作为其值。

不仅仅是Go语言，很多语言都允许一个函数返回多个值。一般会像RetrieveFeeds函数这
样声明一个函数返回一个值和一个错误值。如果发生了错误，永远不要使用该函数返回的另一个
值，否则程序会产生更多的错误，甚至崩溃。

在第 20 行，我们使用内置的 make 函数创建了一个无缓冲的通道。我们使用简化变量声明
运算符，在调用 make 的同时声明并初始化该通道变量。根据经验，如果需要声明初始值为零值
的变量，应该使用 var 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回
值创建变量，应该使用简化变量声明运算符。

在 Go 语言中，通道（channel）和映射（map）与切片（slice）一样，也是引用类型，不过
通道本身实现的是一组带类型的值，这组值用于在 goroutine 之间传递数据。通道内置同步机制，
从而保证通信安全。

在 Go 语言中，如果 main 函数返回，整个程序也就终止了。Go 程序终止时，还会关闭所有
之前启动且还在运行的 goroutine。写并发程序的时候，最佳做法是，在 main 函数返回前，清理
并终止所有之前启动的 goroutine。编写启动和终止时的状态都很清晰的程序，有助减少 bug，防
止资源异常。
这个程序使用 sync 包的 WaitGroup 跟踪所有启动的 goroutine。非常推荐使用 WaitGroup 来
跟踪 goroutine 的工作是否完成。WaitGroup 是一个计数信号量，我们可以利用它来统计所有的
goroutine 是不是都完成了工作。

指针变量可以方便地在函数之间共享数据。使用指针变量可以让函数访问并修改一个变
量的状态，而这个变量可以在其他函数甚至是其他 goroutine 的作用域里声明。

在 Go 语言中，所有的变量
都以值的方式传递。因为指针变量的值是所指向的内存地址，在函数间传递指针变量，是在传递
这个地址值，所以依旧被看作以值的方式在传递。

命名接口的时候，也需要遵守 Go 语言的命名惯例。如果接口类型只包含一个方法，那么这
个类型的名字以 er 结尾。我们的例子里就是这么做的，所以这个接口的名字叫作 Matcher。如
果接口类型内部声明了多个方法，其名字需要与其行为关联。

如果要让一个用户定义的类型实现一个接口，这个用户定义的类型要实现接口类型里声明的
所有方法。

空结构在创建实例时，不会分配任何内存。这种结构很适合创建没有任何状态的类型。

如果声明函数的时候带有接收者，则意味着声明了一个方法。这个方法会和指定的接收者的
类型绑在一起。在我们的例子里，Search 方法与 defaultMatcher 类型的值绑在一起。这意
味着我们可以使用 defaultMatcher 类型的值或者指向这个类型值的指针来调用 Search 方
法。无论我们是使用接收者类型的值来调用这个方，还是使用接收者类型值的指针来调用这个
方法，编译器都会正确地引用或者解引用对应的值 。

因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法
的接收者声明为指针。对于 defaultMatcher 类型来说，使用值作为接收者是因为创建一个
defaultMatcher 类型的值不需要分配内存。由于 defaultMatcher 不需要维护状态，所以
不需要指针形式的接收者。

与直接通过值或者指针调用方法不同，如果通过接口类型的值调用方法，规则有很大不同，
如代码清单 2-38 所示。使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时
候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。

所有的.go 文件，除了空行和注释，都应该在第一行声明自己所属的包。每个包都在一个单
独的目录里。不能把多个包放到同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。
这意味着，同一个目录下的所有.go 文件必须声明同一个包名

在 Go 语言里，命名为 main 的包具有特殊的含义。Go 语言的编译程序会试图把这种名字的
包编译为二进制可执行文件。所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。

每个包可以包含任意多个 init 函数，这些函数都会在程序执行开始的时候被调用。所有被
编译器发现的 init 函数都会安排在 main 函数之前执行。init 函数用在设置包、初始化变量
或者其他要在程序运行前优先完成的引导工作。

也可以在指定包的时候使用通配符。3 个点表示匹配所有的字符串。例如，下面的命令会编译
chapter3 目录下的所有包：
go build github.com/goinaction/code/chapter3/...

声明一个包含 5 个元素的整型数组
var array [5]int
一旦声明，数组里存储的数据类型和数组长度就都不能改变了。

在 Go 语言里，数组是一个值。这意味着数组可以用在赋值操作中。变量名代表整个数组，
因此，同样类型的数组可以赋值给另一个数组

数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相
同的数组，才能互相赋值

编译器会阻止类型不同的数组互相赋值

只要类型一致，就可以将多维数组互相赋值，多维数组的类型包括每一维度的长度以及最终存储在元素中的数据的类型。

切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念
构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数 append 来实现的。这个函
数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的
底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。

切片是一个很小的对象，对底层数组进行了抽象，并提供相关的操作方法。切片有 3 个字段
的数据结构，这些数据结构包含 Go 语言需要操作底层数组的元数据（见图 4-9）。
这 3 个字段分别是指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长
到的元素个数（即容量）。

声明一个包含 5 个元素的整型数组
// 用具体值初始化每个元素
array := [5]int{10, 20, 30, 40, 50}

 创建字符串切片
// 其长度和容量都是 5 个元素
slice := []string{"Red", "Blue", "Green", "Yellow", "Pink"}

创建一个整型切片
// 其长度和容量都是 3 个元素
slice := [ ]int{10, 20, 30}

// 创建字符串切片
// 使用空字符串初始化第 100 个元素
slice := []string{99: ""}
记住，如果在[ ]运算符里指定了一个值，那么创建的就是数组而不是切片。只有不指定值
的时候，才会创建切片，如代码清单 4-21 所示。

// 创建有 3 个元素的整型数组
array := [3]int{10, 20, 30}
// 创建长度和容量都是 3 的整型切片
slice := []int{10, 20, 30}

有时，程序可能需要声明一个值为 nil 的切片（也称 nil 切片）。只要在声明时不做任何初
始化，就会创建一个 nil 切片

创建 nil 整型切片
var slice [ ]int
在 Go 语言里，nil 切片是很常见的创建切片的方法。nil 切片可以用于很多标准库和内置
函数。在需要描述一个不存在的切片时，nil 切片会很好用。

利用初始化，通过声明一个切片可以创建一个空切片，如代码清单 4-23 所示。
代码清单 4-23 声明空切片
// 使用 make 创建空的整型切片
slice := make([ ]int, 0)
// 使用切片字面量创建空的整型切片
slice := [ ]int{}

空切片在底层数组包含 0 个元素，也没有分配任何存储空间。想表示空集合时空切片很有用，
例如，数据库查询返回 0 个查询结果时

不管是使用 nil 切片还是空切片，对其调用内置函数 append、len 和 cap 的效果都是
一样的。

切片只能访问到其长度内的元素。试图访问超出其长度的元素将会导致语言运行时异常

与切片的容量相关联的元素只能用于增长切片。在使用这部分元素前，必须
将其合并到切片的长度里

切片有额外的容量是很好，但是如果不能把这些容量合并到切片的长度里，这些容量就没有
用处。好在可以用 Go 语言的内置函数 append 来做这种合并很容易。

关键字 range 总是会从切片头部开始迭代。如果想对迭代做更多的控制，依旧可以使用传
统的 for 循环

和数组一样，切片是一维的。不过，和之前对数组的讨论一样，可以组合多个切片形成多维
切片

在函数间传递切片就是要在函数间以值的方式传递切片。由于切片的尺寸很小，在函数间复
制和传递切片成本也很低。

映射是一种数据结构，用于存储一系列无序的键值对。
映射里基于键来存储值。图 4-23 通过一个例子展示了映射里键值对是如何存储的。映射功
能强大的地方是，能够基于键快速检索数据。键就像索引一样，指向与该键关联的值。

映射是一个集合，可以使用类似处理数组和切片的方式迭代映射中的元素。但映射是无序的
集合，意味着没有办法预测键值对被返回的顺序。即便使用同样的顺序保存键值对，每次迭代映
射的时候顺序也可能不一样。无序的原因是映射的实现使用了散列表

映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值
可以使用==运算符做比较。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，
不能作为映射的键，使用这些类型会造成编译错误

没有任何理由阻止用户使用切片作为映射的值，如代码清单 4-47 所示。这个在使用一个映射
键对应一组数据时，会非常有用。

可以通过声明一个未初始化的映射来创建一个值为 nil 的映射（称为 nil 映射 ）。nil 映射
不能用于存储键值对，否则，会产生一个语言运行时错误

在 Go 语言里，通过键来索引映射时，即便这个键不存在也总会返回一个值。在这种情况下，
返回的是该值对应的类型的零值。

迭代映射里的所有值和迭代数组或切片一样，使用关键字 range，如代码清单 4-52 所示。
但对映射来说，range 返回的不是索引和值，而是键值对。

如果想把一个键值对从映射里删除，就使用内置的 delete 函数

在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对
这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改

数组是构造切片和映射的基石。

切片有容量限制，不过可以使用内置的 append 函数扩展容量。

映射的增长没有容量或者任何限制。

内置函数 len 可以用来获取切片或者映射的长度。
内置函数 cap 只能用于切片。

将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。

Go 语言是一种静态类型的编程语言。这意味着，编译器需要在编译时知晓程序里每个值的
类型。如果提前知道类型信息，编译器就可以确保程序合理地使用值。这有助于减少潜在的内存
异常和 bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。

任何时候，创建一个变量并初始化为其零值，习惯是使用关键字 var。这种用法是为了更明
确地表示一个变量被设置为零值。如果变量被初始化为某个非零值，就配合结构字面量和短变量
声明操作符来创建变量。

既然要创建并初始化一个结构类型，我们就使用结构字面量来完成这个初始化，如代码清
单 5-4 所示。结构字面量使用一对大括号括住内部字段的初始值。
代码清单 5-4 使用结构字面量创建结构类型的值
13 user{
14 name: "Lisa",
15 email: "lisa@email.com",
16 ext: 123,
17 privileged: true,
18 }

当声明结构类型时，字段的类型并
不限制在内置类型，也可以使用其他用户定义的类型，

当创建具有用户自定义类型字段
的结构类型的变量时，初始化用的结构字面量会有一些变化

另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明。
当需要一个可以用已有类型表示的新类型的时候，这种方法会非常好用，如代码清单 5-8 所示。
标准库使用这种声明类型的方法，从内置类型创建出很多更加明确的类型，并赋予更高级的功能。

代码清单 5-8 展示的是标准库的 time 包里的一个类型的声明。Duration 是一种描述时间
间隔的类型，单位是纳秒（ns）。这个类型使用内置的 int64 类型作为其表示。在 Duration
类型的声明中，我们把 int64 类型叫作 Duration 的基础类型。不过，虽然 int64 是基础
类型，Go 并不认为 Duration 和 int64 是同一种类型。这两个类型是完全不同的有区别的
类型。

编译器很清楚这个程序的问题：类型 int64 的值不能作为类型 Duration 的值来用。换句
话说，虽然 int64 类型是基础类型，Duration 类型依然是一个独立的类型。两种不同类型的
值即便互相兼容，也不能互相赋值。编译器不会对不同类型的值做隐式转换。

方法能给用户定义的类型添加新的行为。方法实际上也是函数，只是在声明时，在关键字
func 和方法名之间增加了一个参数，如代码清单 5-11 所示。

关键字 func 和函数名之间的
参数被称作接收者，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称
为方法。

Go 语言里有两种类型的接收者：值接收者和指针接收者。

值接收者使用
值的副本来调用方法，而指针接受者使用实际值来调用方法。

如果一个创建用的工厂函数返回了一
个指针，就表示这个被返回的值的本质是非原始的。

代码清单 5-33 中的 Chdir 方法展示了，即使没有修改接收者的值，依然是用指针接收者来
声明的。因为 File 类型的值具备非原始的本质，所以总是应该被共享，而不是被复制。
是使用值接收者还是指针接收者，不应该由该方法是否修改了接收到的值来决定。这个决策
应该基于该类型的本质。这条规则的一个例外是，需要让类型值符合某个接口的时候，即便类型
的本质是非原始本质的，也可以选择使用值接收者声明方法。这样做完全符合接口值调用方法的
机制。

要嵌入一个类型，只需要声明这个类型的名字就可以了。注意声明字段和嵌入类型在语法上的不同。

这表明，如果外部类型
实现了 notify 方法，内部类型的实现就不会被提升。不过内部类型的值一直存在，因此还可以
通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。

当要
写的代码属于某个包时，好的实践是使用与代码所在文件夹一样的名字作为包名。所有的 Go 工
具都会利用这个习惯，所以最好遵守这个好的实践。

当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。
如果一个标识符以大写字母开头，这个标识符就是公开的，即被包外的代码可见。

将工厂函数命名为 New 是 Go 语言的一个习惯。

方法提供了一种给用户定义的类型增加行为的方式。
设计类型时需要确认类型的本质是原始的，还是非原始的。

接口是声明了一组行为并支持多态的类型。

嵌入类型提供了扩展类型的能力，而无需使用继承。

标识符要么是从包里公开的，要么是在包里未公开的。

需要强调的是，使用多个逻辑处理器并不意味着性能更好。在修改任何语言运行时配置参数
的时候，都需要配合基准测试来评估程序的运行效果。

对一个共享资源的读和写操作必
须是原子化的，换句话说，同一时刻只能有一个 goroutine 对共享资源进行读和写操作。

当通道关闭后，goroutine 依旧可以从通道接收数据，
但是不能再向通道里发送数据。能够从已经关闭的通道接收数据这一点非常重要，因为这允许通
道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。从一个已经关闭且没有数据的通道
里获取数据，总会立刻返回，并返回一个通道类型的零值。如果在获取通道时还加入了可选的标
志，就能得到通道的状态信息。

可以使用通道来控制程序的生命周期。

带 default 分支的 select 语句可以用来尝试向通道发送或者接收数据，而不会阻塞。

有缓冲的通道可以用来管理一组可复用的资源。

语言运行时 (runtime) 会处理好通道的协作和同步。

使用无缓冲的通道来创建完成工作的 goroutine 池。

任何时间都可以用无缓冲的通道来让两个 goroutine 交换数据，在通道操作完成时一定保
证对方接收到了数据。

一个类型可以自由的使用另一个满足相同接口的类型来进行替换被称作可替换性(LSP里氏替换)。这是一个面向对象的特征。

golang中的方法是作用在指定的数据类型上的（即：和指定的数据类型绑定），因此自定义类型，都可以有方法，而不仅仅是struct

方法的声明和调用

type A struct{

​	Num int

}

func (a A) test(){

​	fmt.Println(a.Num);

} 	// 表示A结构体有一个方法，方法名为test , a(A)体现test方法是个A类型绑定的 ，test方法只能通过Person类型来调用，而不能直接调用，也不能使用其他类型变量来调用

对于普通函数，接受者为值类型时，不能将指针类型的数据直接传递；接受者为指针类型时，不能将值类型的数据直接传递。

而对于方法，接受者为值类型时，可以传递指针类型的数据；接受者为指针类型时，可以传递值类型的数据。注意：不管是指针类型还是值类型，在这里统统都是看方法所属类型的类型，如果方法所属类型的类型值，那么就永远是值拷贝，如果方法所属类型是指针，那么永远是引用传递。

golang的结构体没有构造函数，通常可以使用工厂模式来解决这个问题。如果工厂模式中的new函数里面的字段也是小写开头该咋办呢？答案：我们可以再另外提供一个方法。

golang封装的实现步骤
1) 将结构体，字段（属性）的首字母小写（不能导出了，其他包不能使用，类似private)

2) 给结构体所在包提供一个工厂模式的函数，首字母大写。类似一个构造函数

3）提供一个首字母大写的Set方法（类似其他语言的public), 用于对属性判断并赋值

​	func(var 结构体类型名) SetXxx(参数列表)（返回值列表）{

​	//加入数据验证的业务逻辑

​	var 字段 = 参数

​	}

4）提供一个首字母大写的Get方法（类似其他语言的public），用于获取属性的值

​	func (var 结构体类型名) GetXxx(){

​		return var 字段；

​	}

特别说明：在Golang开发中并没有特别强调封装，这点并不像java,所以提醒学过java的朋友，不要总是用java的语法特性来看待Golang, Golang 本身对面向对象的特性做了简化的。

继承可以解决代码复用，让我们的编程更加靠近人类思维。

当多个结构体存在相同属性（字段）和方法时，可以从这些结构体中抽象出结构体（比如刚才的Student) ，在该结构体中定义这些相同的属性（字段）和方法。

其他的结构体不需要重新定义这些属性和方法，只需嵌套一个Student匿名结构体即可。

也就是说：在Golang中，如果一个struct嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性。 

 嵌套匿名结构体的基本语法：

​	type Goods struct {

​		Name string

​		Price int

​	}

​	type Book struct {

​		Goods   	// 这里就是嵌套匿名结构体 ，此时Book就相当于拥有了Name 和 Price 两个字					段

​		Writer string

​	}

​	继承的深入讨论

​	1）结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大写或者首字母小写的字段和方法都可以使用。

​	2）匿名结构体字段访问可以简化。

​	3）当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如果希望访问匿名结构体的字	段和方法，可以通过匿名结构体名来区分。

​	4）结构体嵌入两个（或多个）匿名结构体，例如两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的	字段和方法），在访问时，就必须明确指定匿名结构体名字，否则编译报错。

​	5）如果一个struct嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或	方法时，必须带上结构体的名字

​	6）嵌套匿名结构体后，也可以在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值。如下

​		tv := TV { Goods {"电视剧001"，5000}，Brand {“海尔”，“山东”} }

​	结构体的匿名字段可以是基本数据类型，比如Int等，但是不能重复。

多重继承

​	如果一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现了多	重继承。

​	如果嵌入的匿名结构体有相同的字段和方法名，则在访问时，需要通过匿名结构体类型名来区分。

​	为了保证代码的简洁性，建议大家尽量不适用多重继承。

接口（Interface）

​	interface类型可以定义一组方法，但是这些不需要实现。并且Interface不能包含任何变量。到某个自定义类型（比如	结构体Phone）要使用的时候，再根据具体情况把这些方法写出来。

​	接口说明：

​		1）接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的多态和高内聚	和低耦合思想

​		2）Golang中的接口，不需要显示的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现了	这个接口。因此，Golang中没有implement这样的关键字。

​	接口的注意事项和细节

​		1）接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量（实例）

​		2）接口中所有的方法都没有方法体，即都是没有实现的方法。

​		3）在Golang中，一个自定义类型需要将某个接口的所有方法都实现，我们才说这个自定义类型实现了该接口。

​		4）一个自定义类型只有实现了某个接口，才能将该自定义类型的实例（变量）赋给接口类型。

​		5）只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型。

​		6）一个自定义类型可以实现多个接口

​		7）Golang接口中不能有任何变量，只能有方法。

​		8）一个接口（比如A接口）可以继承多个别的接口（比如B,C接口），这时如果要实现A接口，也必须将B，C			接口的方法也全部实现

​			// Golang是基于方法来实现接口的

​		9）interface 类型默认是一个指针（引用类型），如果没有对interface初始化就使用，那么会输出nil

​		10) 空接口interface{} 没有任何方法，所以所有类型都实现了空接口，即我们可以把任何一个变量赋给空接口

​	当A结构体继承了B结构体，那么A结构就自动继承了B结构体的字段和方法，并且可以直接使用

​	当A结构体需要扩展功能，同时不希望去破坏继承关系，则可以去实现某个接口即可。因此我们可以认为，实现接口	是对继承机制的补充。

​	实现接口 VS 继承

​	接口和继承解决的问题不同

​		继承的价值主要在于：解决代码的复用性和可维护性。

​		接口的价值主要在于：设计，设计好各种规范（方法），让其他自定义类型去实现这些方法。

​	接口比继承更加灵活

​		接口比继承更加灵活，继承是满足 is - a的关系，而接口只需满足like - a的关系。

​	接口在一定程度上实现代码解耦

​	接口体现多态特征

​		1）多态参数

​		在前面的Usb接口案例，Usb usb，即可以接受手机变量，又可以接受相机变量，就体现了Usb接口多态

​		2）多态数组

​		演示一个案例：给Usb数组中，存放Phone结构体和Camera结构体变量，Phone还有一个特有的方法call(),请遍		历usb数组，如果是Phone变量，除了调用Usb接口声明的方法外，还需要调用Phone特有方法call. ->需要类型		断言 

​	在进行类型断言时，如果类型不匹配，就会报panic，因此进行类型断言时，要确保原来的空接口指向的就是要断言	的类型

​	如何在进行断言时，带上检测机制，如果成功就OK，否则也不要报panic

Golang数据结构与算法

​	1）稀疏数组

​		基本介绍

​		当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

​		稀疏数组的处理方法是：

​		1）记录数组一共有几行几列，有多少个不同的值

​		2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

