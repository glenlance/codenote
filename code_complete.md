问题定义：我不会组织项目结构，不知道接下来该干嘛？

​	问题定义在具体的需求分析工作之前，而需求分析是对所定义的问题深入调查。

结对编程

单人开发

形式化检查

核对表： 主要的构建实践

编码：

​	1，你有没有确定，多少设计工作将要预先进行，多少设计工作在键盘上进行？

​	2， 你有没有规定诸如名称，注释，代码格式等编码约定？

​	3，你有没有规定特定的由软件架构确定的编码实践，比如如何处理错误条件，如何处理安全性事项，对于类接口有哪些约定，可重用的代码遵循哪些标准，在编码时考虑多少性能因素？

​	4，你有没有找到自己在技术浪潮中的位置，并相应调整自己的措施？如果必要，你是否知道如何“深入一种语言去编程”，而不受限于语言？

团队工作：

​	1，你有没有定义一套集成工序-------------即，你有没有定义一套特定的步骤，规定程序员在把代码check in(签入)到主源码中之前，必须履行这些步骤？

​	2，程序员是结对编程，还是独自编程，或者这两者的某种结合？

质量保证：

​	1，程序员在编写代码之前，是否先为之编写测试用例？

​	2，程序员会为自己的代码写单元测试吗？（无论是先写还是后写）

​	3，程序员在check in代码之前，会用调试器单步跟踪整个代码流程吗？

​	4，程序员在check in代码之前，是否会进行集成测试？

​	5，程序员会复审（review) 或检查别人的代码吗？

工具

​	1，你是否选用了某种版本控制工具？

​	2，你是否选定了一种语言，以及语言的版本或者编译器版本？

​	3，你是否选择了某个编程框架，或者明确的决定不使用编程框架？

​	4，你是否决定允许使用非标准的语言特性？

​	5，你是否决定并拥有了其他将要用到的工具-----------编辑器，重构工具，调试器，测试框架，语法检查器等？

软件设计一词意味着去构思，创造或者发明一套方案，把一份计算机软件的规格说明书要求转变为可实际运行的软件。设计就是把需求分析和编码调试连在一起的活动。好的高层次设计能提供一个可以稳妥容纳多个较低层次设计的结构。好的设计对于小型项目非常有用，对于大型项目更是不可或缺。

在这一层次中，有一点特别重要，即不同子系统之间相互通信的规则。如果所有的子系统都能同其他子系统通信，你就完全失去了把他们分开所带来的好处。应该通过限制子系统之间的通信来让每个子系统更有存在意义。

你可以把子系统之间的连线当成水管。当你想去掉某个子系统时，势必会有不少水管连在上面。你需要断开再重新连接的水管数量越多，弄出来的水就会越多。你肯定想把系统的架构设计成这样：如果想把某个子系统取走重用时，不用重新链接太多水管，重新连接起来也不会太难。

为了让子系统之间的连接简单易懂且易于维护，就要尽量简化子系统之间的交互关系。最简单的交互关系是让一个子系统去调用另一个子系统中的子程序；稍微复杂点儿的交互关系是在一个子系统中包含另一个子系统中的类；而最复杂的交互关系是让一个子系统中的类继承自另一个子系统中的类。

有一条很好的基本原则，即，系统层设计图应该是无环图（acyclic graph)。换句话说，程序中不应该有任何环形关系，比如说A类使用了B类，B类使用了C类，而C类又使用了A类这种情况。

对于大型程序或一系列程序而言，在子系统这一层次上进行设计是至关重要的。

业务规则：业务规则是指那些在计算机系统中编入的法律，规则，政策以及过程。

用户界面

数据库访问

对系统的依赖性：把对操作系统的依赖因素归到一个子系统里，就如同把对硬件的以来因素封装起来一样。比如说，你在开发一个运行于Microsoft Windows操作系统上的程序，可为什么一定要把自己局限于Windows的环境呢？把所有与Windows相关的系统调用都隔离起来，放到一个Windows接口子系统中，这样一来，如果日后你想把程序移植到Mac OS 或Linux操作系统时，只要修改接口子系统就可以了。自己实现这一接口子系统可能会太复杂了，但一些商业代码库都已经提供了这一子系统的现成实现。

对象对其他对象暴露的数据及方法都被称为该对象的“公开接口/public interface”，而对象通过继承关系向其派生对象暴漏的部分则被称为“受保护的接口/protected interface"。要考虑这两种不同的接口。

软件开发人员又是就是在木材纤维，油漆分子以及铁原子这一层次来构建系统，系统因此变得异常复杂，难以通过人的智力去管理。当程序员没有给出足够高层的编程抽象时，系统有时就会被卡在门口了。

优秀的程序员会在子程序接口的层次上，在类接口的层次上以及包接口的层次上 —— 换句话说，在门把手的层次上，们的层次上以及房屋的层次上 —— 进行抽象，这样才能更快，更稳妥地进行开发。

封装实现细节

封装填补了抽象留下的空白。抽象是说：“可以让你从高层的细节来看待一个对象。” 而封装则说：“除此之外，你不能看到对象的任何其他细节层析。“

封装是说，不只是让你能用简化的视图来看复杂的观念，同时还不能让你看到复杂概念的任何细节。你能看到的就是你能全部得到的。

当继承能简化设计时就继承

编程语言如果能支持像Open() 或Close() 这样在运行期间才能确定所针对的对象的实际类型的操作，这种能力叫做”多态”。

继承很强大。如果使用得当，带来很大的益处，否则带来很大的麻烦。

信息隐藏时结构化程序设计与面向对象设计的基础之一。结构化设计里面的“黑盒子” 概念就是来源于信息隐藏。信息隐藏是软件的首要技术使命中格外重要的一种启发式方法，因为他强调的就是隐藏复杂度。

再强调一下，隐藏设计决策对于减少 ”改动所影响的代码量“ 而言是至关重要的。

信息隐藏在设计的所有层次上都有很大作用 —— 从使用具名常量替代字面量（literal) ，到创建数据类型，再到类的设计，子程序的设计以及子系统的设计等等。

两种需要隐藏的

​	1，隐藏复杂度，这样你就不用再去应付它，除非你要特别关注的时候。

​	2，隐藏变化源，这样当变化发生时，其影响就能被限制在局部范围内。复杂度的根源包括复杂的数据类型，文件结构，布尔判断以及晦涩的算法等等。

信息隐藏的障碍

​	在少数情况下，信息隐藏是根本不可能的。不多大多数让信息无法隐藏的障碍都是由于惯用某些技术而导致的心里障碍。

​	1，信息过度分散

​	2，循环依赖

​	3，把类内部数据误认为全局数据

​	4，可以察觉的性能损耗

全局数据通常会受困与两类问题：

​	1，子程序在全局数据上执行操作，但却不知道还有其他的子程序也在用这些全局数据进行操作；

​	2，子程序知道其他的子程序也在用全局数据进行操作，但却无法明确知道都进行了哪些操作。

​	而类的内部数据就不会遇到这两种问题，因为只有类内部的少数子程序才能直接访问这些数据。这些子程序不但知道	有其他子程序在操纵这些数据，而且也明确知道具体是哪些子程序在执行这些操作。

面向对象设计也会和信息隐藏一样接受这种设计方案。两者之间的差别更多地是在于，按照信息隐藏的原则来思考，能够激发和促进某些设计决策的形成，而仅仅按照对象原则思考则不会。其差异也很有启发性。

​	问题 ” 这个类需要隐藏什么 “ 正切中了接口设计的核心。如果你能在类的公开接口中增加函数或这数据而不牺牲该类的隐秘性，那么就做下去，否则请停住。

​	在设计的所有层面上，都可以通过询问该隐藏些什么来促成好的设计决策。这一问题可以在构建层面（ construction level )上协助你使用具体名字的常量来取代字面量，可以在类的内部生成浩的子程序和参数名称，还有助于指导在系统层上做出有关类和子系统分解以及交互设计的决策。

​	请养成问 “我该隐藏写什么？” 的习惯，你会惊奇地发现，有很多棘手的设计难题都会在你面前化解。

找出容易改变的区域

​	对优秀设计师的一份研究表明，他们所共有的一项特质就是都有对变化的预期能力。

状态变量

​	状态变量用于表示程序的状态，与大多数其他的数据相比，这种东西更容易改变。在一个典型的应用场景里，你可能一开始用布尔变量来定义出错状态，然后又发现用具有ErrorType_None，ErrorType_Warning 和ErrorType_Fatal 等值的类枚举类型来表示状态更好。

保持松散耦合

​	模块之间的好的耦合关系会松散到恰好能使一个模块能够很容易地被其他模块使用。火车之间之所以能够相连就是因为这种连接尽可的简单。在软件中，也请确保模块之间的链接关系尽可能简单。

​	请尽量使你创建的模块不依赖或者很少依赖其他模块。

​	类和子程序是用于降低复杂度的首选和最重要的智力工具。如果他们没帮助你简化工作，那么他们就是失职的。

设计模式是一种非常强大的管理复杂度的工具。